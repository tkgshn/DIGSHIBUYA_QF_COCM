<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DigDAO Simulation Comparison - 通常QFとCOCM QFの比較</title>
    <meta name="description" content="DigDAOの寄付データを使用して、通常のQuadratic Funding（QF）とConnection-Oriented Cluster Matching QF（COCM QF）を比較するシミュレーション。多様性を重視するCOCM QFがどのように資金配分を改善するかを視覚的に理解できます。" />
    <meta name="keywords" content="DigDAO, Quadratic Funding, QF, COCM, Connection-Oriented Cluster Matching, 寄付, クラスタリング, 多様性, シミュレーション, 可視化" />
    <meta name="author" content="DigDAO" />
    <meta name="robots" content="index, follow" />

    <!-- OGP設定 (SNSシェア用) -->
    <meta property="og:title" content="DigDAO QF Simulation Comparison - 通常QFとCOCM QFの比較" />
    <meta property="og:description" content="DigDAOの寄付データを使用して、通常のQFとCOCM QFを比較。多様性を重視するCOCM QFがどのように資金配分を改善するかを視覚的に理解できます。" />
    <meta property="og:image" content="https://i.gyazo.com/ab9353bd6fe0e963c752728f925630c2.png" />
    <meta property="og:url" content="https://tkgshn.github.io/DIGSHIBUYA_QF_COCM/digdao/index" />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="DigDAO QF Simulation" />
    <meta property="og:locale" content="ja_JP" />

    <!-- Twitter Card設定 -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="DigDAO QF Simulation Comparison" />
    <meta name="twitter:description" content="通常のQFとCOCM QFの比較シミュレーション。多様性を重視するCOCM QFの効果を可視化。" />
    <meta name="twitter:image" content="https://i.gyazo.com/8cbad85d56ff3a1675a989d6cc61de3e.png" />

    <!--
    このアプリケーションについて:
    寄付データを分析し、通常のQF（Quadratic Funding）とCOCM QF（Connection-Oriented Cluster Matching QF）の
    比較シミュレーションを行います。寄付フロー、寄付者クラスタリング、資金配分の可視化を含みます。
    -->
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #121212;
            color: #f0f0f0;
        }

        .p-6 {
            padding: 1.5rem;
        }

        .text-xl {
            font-size: 1.25rem;
        }

        .text-3xl {
            font-size: 2rem;
        }

        .font-bold {
            font-weight: bold;
        }

        .mb-4 {
            margin-bottom: 1rem;
        }

        .mt-6 {
            margin-top: 1.5rem;
        }

        .flex {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            width: 100%;
        }

        .half {
            flex: 1;
            min-width: 300px;
            max-width: calc(50% - 10px);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 0.5rem;
            table-layout: fixed;
            background-color: #1e1e1e;
        }

        table,
        th,
        td {
            border: 1px solid #444;
        }

        th,
        td {
            padding: 5px;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            word-wrap: break-word;
            color: #f0f0f0;
        }

        td.donation-breakdown {
            max-width: 150px;
            font-size: 0.8rem;
        }

        input {
            margin-left: 5px;
            background-color: #333;
            color: #f0f0f0;
            border: 1px solid #555;
            padding: 5px;
        }

        button {
            padding: 0.5rem 1rem;
            cursor: pointer;
            background-color: #2a6496;
            color: white;
            border: none;
            border-radius: 4px;
        }

        button:hover {
            background-color: #1e4b75;
        }

        .chart-container {
            margin-top: 20px;
        }

        .info-box {
            background-color: #1e1e1e;
            border: 1px solid #444;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .highlight {
            color: #4fc3f7;
            font-weight: bold;
        }

        a {
            color: #64b5f6;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <!-- ライブラリ読み込み -->
    <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>

    <!-- メインの React コンポーネント -->
    <script type="text/babel">
        /**
         * k-meansクラスタリング関数
         *
         * @param {Array<Array<number>>} data - クラスタリングするデータ（各行が寄付者、各列がプロジェクトへの寄付額）
         * @param {number} k - クラスタ数（デフォルト: 3）
         * @returns {Object} クラスタ割り当てと中心点の情報
         *
         * 寄付者の寄付パターンに基づいて、類似した寄付行動を持つ寄付者をグループ化します。
         * これにより、多様性係数の計算に使用されます。
         */
        function kMeansClusteringWithAssignments(data, k = 3) {
            if (!data || !data.length || !data[0] || !data[0].length) {
                return { assignments: [], centroids: [] };
            }

            try {
                let centroids = data.slice(0, k).map(pt => pt.slice());
                // もしデータが足りない場合は、ランダムな初期中心点を生成
                if (centroids.length < k) {
                    // 各次元の最小値と最大値を計算
                    const dims = data[0].length;
                    const mins = Array(dims).fill(Infinity);
                    const maxs = Array(dims).fill(-Infinity);
                    data.forEach(pt => {
                        for (let i = 0; i < dims; i++) {
                            mins[i] = Math.min(mins[i], pt[i]);
                            maxs[i] = Math.max(maxs[i], pt[i]);
                        }
                    });

                    // 足りない中心点をランダムに生成
                    while (centroids.length < k) {
                        const randPt = Array(dims).fill(0).map((_, i) =>
                            mins[i] + Math.random() * (maxs[i] - mins[i])
                        );
                        centroids.push(randPt);
                    }
                }

                let assignments = new Array(data.length).fill(0);
                let changed = true;
                let iterations = 0;
                const MAX_ITERATIONS = 100; // 無限ループ防止

                while (changed && iterations < MAX_ITERATIONS) {
                    iterations++;
                    changed = false;
                    const newAssignments = data.map(point => {
                        let minDist = Infinity, clusterIndex = 0;
                        centroids.forEach((centroid, i) => {
                            const dist = Math.sqrt(
                                centroid.reduce((sum, c, j) => sum + Math.pow(point[j] - c, 2), 0)
                            );
                            if (dist < minDist) {
                                minDist = dist;
                                clusterIndex = i;
                            }
                        });
                        return clusterIndex;
                    });
                    for (let i = 0; i < data.length; i++) {
                        if (newAssignments[i] !== assignments[i]) {
                            changed = true;
                            break;
                        }
                    }
                    assignments = newAssignments;
                    const newCentroids = Array.from({ length: k }, () => new Array(data[0].length).fill(0));
                    const counts = new Array(k).fill(0);
                    data.forEach((point, idx) => {
                        const cluster = assignments[idx];
                        counts[cluster]++;
                        point.forEach((val, j) => {
                            newCentroids[cluster][j] += val;
                        });
                    });
                    for (let i = 0; i < k; i++) {
                        if (counts[i] > 0) {
                            newCentroids[i] = newCentroids[i].map(v => v / counts[i]);
                        }
                    }
                    centroids = newCentroids;
                }
                return { assignments, centroids };
            } catch (e) {
                console.error("k-meansクラスタリング中にエラーが発生しました:", e);
                return { assignments: [], centroids: [] };
            }
        }

        /**
         * PCAによる2次元射影関数
         *
         * @param {Array<Array<number>>} data - 高次元データ（寄付者×プロジェクトの行列）
         * @param {number} numComponents - 次元削減後の次元数（デフォルト: 2）
         * @returns {Array<Array<number>>} 次元削減後のデータ
         *
         * 高次元の寄付データを2次元に圧縮し、可視化しやすくします。
         * 主成分分析（PCA）を使用して、データの最も重要な特徴を保持しながら次元を削減します。
         */
        function pcaProjection(data, numComponents = 2) {
            // データがない場合や不正な場合は空の配列を返す
            if (!data || !data.length || !data[0] || !data[0].length) {
                return [];
            }

            const n = data.length, d = data[0].length;

            try {
                // 行数が列数より少ない場合は、簡易的な次元削減を行う
                if (n < d) {
                    console.log(`PCA: 行数(${n})が列数(${d})より少ないため、簡易的な次元削減を行います`);

                    // 各行の合計と分散を計算
                    const rowSums = data.map(row => row.reduce((sum, val) => sum + val, 0));
                    const rowMean = rowSums.reduce((sum, val) => sum + val, 0) / n;
                    const rowVariance = rowSums.map(val => Math.pow(val - rowMean, 2))
                                              .reduce((sum, val) => sum + val, 0) / n;

                    // 各列の合計を計算
                    const colSums = [];
                    for (let j = 0; j < d; j++) {
                        let sum = 0;
                        for (let i = 0; i < n; i++) {
                            sum += data[i][j];
                        }
                        colSums.push(sum);
                    }

                    // 簡易的な2次元座標を生成
                    return data.map((row, i) => {
                        // 第1成分: 行の合計（寄付総額）を正規化
                        const comp1 = rowSums[i] / Math.max(1, Math.sqrt(rowVariance));

                        // 第2成分: 寄付パターンの重み付け
                        let comp2 = 0;
                        for (let j = 0; j < d; j++) {
                            // 列の重要度に基づいて重み付け
                            const weight = colSums[j] / Math.max(1, Math.max(...colSums));
                            comp2 += row[j] * weight * (j % 2 === 0 ? 1 : -1); // 交互に正負の重みを付ける
                        }

                        // 第3成分（3D用）
                        let comp3 = 0;
                        if (numComponents > 2) {
                            for (let j = 0; j < d; j++) {
                                comp3 += row[j] * Math.sin(j * Math.PI / d);
                            }
                        }

                        return numComponents > 2 ? [comp1, comp2, comp3] : [comp1, comp2];
                    });
                }

                // 通常のPCA（行数 >= 列数の場合）
                const means = [];
                for (let j = 0; j < d; j++) {
                    let sum = 0;
                    for (let i = 0; i < n; i++) {
                        sum += data[i][j];
                    }
                    means[j] = sum / n;
                }

                const centered = data.map(row => row.map((val, j) => val - means[j]));
                const svd = numeric.svd(centered);
                const V = svd.V;
                const proj = centered.map(row => {
                    const projected = [];
                    for (let i = 0; i < numComponents; i++) {
                        let val = 0;
                        for (let j = 0; j < d; j++) {
                            val += row[j] * V[j][i];
                        }
                        projected.push(val);
                    }
                    return projected;
                });
                return proj;
            } catch (e) {
                console.error("PCA計算中にエラーが発生しました:", e);

                // エラー発生時は簡易的な座標を返す
                return data.map((row, i) => {
                    // 各行の合計と分散を使用
                    const rowSum = row.reduce((sum, val) => sum + val, 0);
                    // 行の合計を第1成分、インデックスを第2成分として使用
                    const result = [rowSum, i * 0.1];
                    // 3D用に第3成分を追加
                    if (numComponents > 2) {
                        result.push((i % 3) * 0.2);
                    }
                    return result;
                });
            }
        }

        /**
         * DonationSimulator メインコンポーネント
         *
         * アプリケーション全体を管理するメインコンポーネント。
         * データの読み込み、処理、QFシミュレーション計算、可視化を行います。
         */
        function DonationSimulator() {
            const [matchingPool, setMatchingPool] = React.useState(100000);
            const [refresh, setRefresh] = React.useState(0);
            const [rawDonationData, setRawDonationData] = React.useState([]);
            const [isLoading, setIsLoading] = React.useState(true);
            const [error, setError] = React.useState(null);

/**
 * JSONデータ読み込み処理
 *
 * Contribution.jsonとGrants.jsonファイルから寄付データとプロジェクト情報を読み込みます。
 * データ読み込み中はローディング状態を表示し、エラー処理も行います。
 */
React.useEffect(() => {
    setIsLoading(true);
    let isMounted = true; // コンポーネントがマウントされているかを追跡

    // 両方のJSONファイルを並行して読み込む
    Promise.all([
        fetch('Contribution.json')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Contribution.json HTTPエラー: ${response.status}`);
                }
                return response.json();
            }),
        fetch('Grants.json')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Grants.json HTTPエラー: ${response.status}`);
                }
                return response.json();
            })
    ])
    .then(([contributionData, grantsData]) => {
        if (isMounted) { // コンポーネントがまだマウントされている場合のみ状態を更新
            console.log('寄付データ読み込み成功:', contributionData.length, '件');
            console.log('プロジェクトデータ読み込み成功:', grantsData.length, '件');
            setRawDonationData(contributionData);
            // プロジェクト情報をグローバル変数として保存
            window.grantsData = grantsData;
            setIsLoading(false);
        }
    })
    .catch(err => {
        if (isMounted) { // コンポーネントがまだマウントされている場合のみ状態を更新
            console.error('データ読み込みエラー:', err);
            setError(`データ読み込みに失敗しました: ${err.message}`);
            setIsLoading(false);
        }
    });

    // クリーンアップ関数
    return () => {
        isMounted = false; // コンポーネントがアンマウントされたらフラグを更新
    };
}, [refresh]);

            /**
             * データ変換処理
             *
             * 生の寄付データから以下の情報を抽出・生成します:
             * 1. 寄付者リスト: 一意の寄付者ID
             * 2. プロジェクトリスト: 一意のプロジェクトID
             * 3. tableData: 寄付者×プロジェクトの寄付額テーブル
             * 4. links: Sankey図用の寄付フローデータ
             * 5. donationMatrix: クラスタリング用の行列データ
             */
            const donors = React.useMemo(() => {
                return [...new Set(rawDonationData.map(r => r.userId))];
            }, [rawDonationData]);

            const projects = React.useMemo(() => {
                return [...new Set(rawDonationData.map(r => r.grantId).filter(id => id))];
            }, [rawDonationData]);

            const tableData = React.useMemo(() => {
                let tData = {};
                donors.forEach(donor => {
                    tData[donor] = {};
                    projects.forEach(project => {
                        tData[donor][project] = 0;
                    });
                });
                rawDonationData.forEach(record => {
                    const donor = record.userId;
                    const project = record.grantId;
                    if (!donor || !project) return;
                    tData[donor][project] += record.amount;
                });
                return tData;
            }, [donors, projects, rawDonationData]);

            const links = React.useMemo(() => {
                let ls = [];
                donors.forEach(donor => {
                    projects.forEach(project => {
                        const amt = tableData[donor][project];
                        if (amt > 0) {
                            ls.push({ source: donor, target: project, value: amt });
                        }
                    });
                });
                return ls;
            }, [tableData, donors, projects]);

            /**
             * 寄付行列の生成
             *
             * 行=寄付者、列=プロジェクトの行列を生成します。
             * この行列はクラスタリングや多様性分析に使用されます。
             */
            const donationMatrix = React.useMemo(() => {
                return donors.map(donor => projects.map(project => tableData[donor][project]));
            }, [donors, projects, tableData]);

            /**
             * 寄付者クラスタリング
             *
             * 寄付行列に対してk-meansクラスタリングを適用し、
             * 寄付者を類似した寄付パターンに基づいてグループ化します。
             * 結果は多様性係数の計算と2D可視化に使用されます。
             */
            const { assignments } = React.useMemo(() =>
                donors.length > 0 && projects.length > 0 ?
                kMeansClusteringWithAssignments(donationMatrix, 3) :
                { assignments: [] }
            , [donationMatrix]);

            /**
             * QFシミュレーション計算関数
             *
             * 各プロジェクトについて、QF（Quadratic Funding）の計算を行います。
             * 1. 寄付額の平方根の合計を二乗してbaseScoreを計算
             * 2. 寄付者の多様性に基づいてdiversityFactorを計算
             * 3. 通常QFとCOCM QF（多様性にボーナスを付与）の両方を計算
             * 4. マッチングプールから各プロジェクトへの配分額を計算
             *
             * @returns {Object} 通常QFとCOCM QFのプロジェクト集計情報
             */
            function computeProjectSummaries() {
                if (donors.length === 0 || projects.length === 0 || !assignments.length) {
                    return { normal: [], cocm: [] };
                }

                let normal = [];
                let cocm = [];
                projects.forEach(project => {
                    let totalDonation = 0;
                    let donorCount = 0;
                    let donationBreakdown = [];
                    let sumSqrt = 0;
                    let clustersSet = new Set();
                    donors.forEach((donor, i) => {
                        const amt = tableData[donor][project];
                        totalDonation += amt;
                        if (amt > 0) {
                            donorCount++;
                            donationBreakdown.push(amt);
                            sumSqrt += Math.sqrt(amt);
                            clustersSet.add(assignments[i]);
                        }
                    });
                    const baseScore = Math.pow(sumSqrt, 2);
                    const diversityFactor = clustersSet.size / 3; // 3は固定クラスタ数
                    // 通常のQF
                    const newScore_normal = baseScore * diversityFactor;
                    // COCMの場合： diversityFactorにボーナス（例：+0.5）を付与
                    const newScore_cocm = baseScore * (diversityFactor + 0.5);

                    normal.push({
                        project,
                        totalDonation,
                        donorCount,
                        donationBreakdown,
                        baseScore,
                        diversityFactor,
                        newScore: newScore_normal
                    });
                    cocm.push({
                        project,
                        totalDonation,
                        donorCount,
                        donationBreakdown,
                        baseScore,
                        diversityFactor,
                        newScore: newScore_cocm
                    });
                });
                // 各方式での総スコア
                const totalNewScore_normal = normal.reduce((sum, p) => sum + p.newScore, 0);
                const totalNewScore_cocm = cocm.reduce((sum, p) => sum + p.newScore, 0);
                // マッチング額を割り当て
                normal = normal.map(p => ({
                    ...p,
                    finalMatchingFunds: totalNewScore_normal ? (p.newScore / totalNewScore_normal * matchingPool) : 0
                }));
                cocm = cocm.map(p => ({
                    ...p,
                    finalMatchingFunds: totalNewScore_cocm ? (p.newScore / totalNewScore_cocm * matchingPool) : 0
                }));
                return { normal, cocm };
            }

            const { normal: projectSummaries_normal, cocm: projectSummaries_cocm } = React.useMemo(() => computeProjectSummaries(), [tableData, donors, projects, matchingPool, assignments]);

            // ----------------- Plotly描画 -----------------

            /**
             * Sankey Diagram（寄付フロー可視化）
             *
             * 寄付者からプロジェクトへの資金フローをSankey図で可視化します。
             * 寄付の流れと規模を直感的に理解できるようにします。
             */
            React.useEffect(() => {
                if (donors.length === 0 || projects.length === 0 || links.length === 0) {
                    return; // データが不足している場合は描画しない
                }

                // 描画処理を少し遅らせる
                const timer = setTimeout(() => {
                    try {
                        // DOM要素が存在するか確認
                        const element = document.getElementById("sankeyDiv");
                        if (!element) {
                            console.warn("sankeyDiv要素が見つかりません");
                            return;
                        }

                        // プロジェクト名に変換
                        const projectLabels = projects.map(projectId => {
                            return window.grantsData && window.grantsData.find(g => g.id === projectId)
                                ? window.grantsData.find(g => g.id === projectId).name
                                : projectId;
                        });
                        const nodeLabels = [...donors, ...projectLabels];
                        const nodeMap = {};
                        // ドナーのマッピング
                        donors.forEach((label, i) => nodeMap[label] = i);
                        // プロジェクトのマッピング（元のIDを使用）
                        projects.forEach((projectId, i) => nodeMap[projectId] = i + donors.length);
                        const sankeySource = links.map(link => nodeMap[link.source]);
                        const sankeyTarget = links.map(link => nodeMap[link.target]);
                        const sankeyValues = links.map(link => link.value);
                        const sankeyTrace = {
                            type: "sankey",
                            orientation: "h",
                            node: {
                                pad: 5,
                                thickness: 20,
                                line: { color: "black", width: 0.5 },
                                label: nodeLabels
                            },
                            link: {
                                source: sankeySource,
                                target: sankeyTarget,
                                value: sankeyValues
                            }
                        };
                        Plotly.newPlot("sankeyDiv", [sankeyTrace], {
                            title: "Donation Flow Sankey Diagram",
                            font: { size: 10, color: "#f0f0f0" },
                            height: 500,
                            paper_bgcolor: "#121212",
                            plot_bgcolor: "#121212"
                        });
                    } catch (e) {
                        console.error("サンキーダイアグラム描画中にエラーが発生しました:", e);
                    }
                }, 500); // 500ミリ秒の遅延

                // クリーンアップ関数
                return () => clearTimeout(timer);
            }, [links, donors, projects, rawDonationData]);

            /**
             * 3Dネットワーク可視化
             *
             * 寄付者とプロジェクトの関係を3D空間で可視化します。
             * 寄付者は赤色、プロジェクトは青色で表示され、寄付関係は緑色の線で表されます。
             * ノードのサイズは寄付額や受取額に比例します。
             */
            React.useEffect(() => {
                if (donors.length === 0 || projects.length === 0 || !assignments.length) {
                    return; // データが不足している場合は描画しない
                }

                // 描画処理を少し遅らせる
                const timer = setTimeout(() => {
                    try {
                        // DOM要素が存在するか確認
                        const element = document.getElementById("network3dDiv");
                        if (!element) {
                            console.warn("network3dDiv要素が見つかりません");
                            return;
                        }

                        // データを処理して可視化用のデータ構造に変換する関数
                        function processData() {
                            // プロジェクト（助成金）のマップを作成
                            const projectsMap = {};
                            projects.forEach(project => {
                                projectsMap[project] = {
                                    id: project,
                                    name: window.grantsData && window.grantsData.find(g => g.id === project) ?
                                        window.grantsData.find(g => g.id === project).name : project,
                                    donationTotal: 0,
                                    donorCount: 0,
                                    donors: new Set(),
                                    exclusiveDonors: new Set() // そのプロジェクトにのみ寄付しているドナーのセット
                                };
                            });

                            // ドナー（寄付者）のマップを作成
                            const donorsMap = {};
                            donors.forEach(donor => {
                                donorsMap[donor] = {
                                    id: donor,
                                    donations: [],
                                    projectIds: new Set() // 寄付したプロジェクトのIDセット
                                };
                            });

                            // 寄付データを処理
                            const processedLinks = [];

                            // tableDataから寄付情報を抽出
                            donors.forEach(donor => {
                                projects.forEach(project => {
                                    const amt = tableData[donor][project];
                                    if (amt > 0) {
                                        // 寄付情報を追加
                                        const link = {
                                            source: donor,
                                            target: project,
                                            value: amt,
                                            flagged: false // 不審フラグ（デフォルトはfalse）
                                        };

                                        processedLinks.push(link);
                                        donorsMap[donor].donations.push(link);
                                        donorsMap[donor].projectIds.add(project);

                                        // プロジェクト統計を更新
                                        projectsMap[project].donationTotal += amt;
                                        projectsMap[project].donors.add(donor);
                                    }
                                });
                            });

                            // 各ドナーが寄付したプロジェクト数を計算
                            Object.values(donorsMap).forEach(donor => {
                                donor.projectCount = donor.projectIds.size;

                                // 1つのプロジェクトにのみ寄付しているドナーを特定
                                if (donor.projectCount === 1) {
                                    const projectId = Array.from(donor.projectIds)[0];
                                    projectsMap[projectId].exclusiveDonors.add(donor.id);
                                }
                            });

                            // プロジェクトの寄付者数と排他的寄付者の割合を計算
                            Object.values(projectsMap).forEach(project => {
                                project.donorCount = project.donors.size;
                                project.exclusiveDonorCount = project.exclusiveDonors.size;
                                project.exclusiveDonorRatio = project.donorCount > 0 ?
                                    project.exclusiveDonorCount / project.donorCount : 0;
                            });

                            // 配列に変換
                            const processedProjects = Object.values(projectsMap);
                            const processedDonors = Object.values(donorsMap);

                            return {
                                projects: processedProjects,
                                donors: processedDonors,
                                links: processedLinks,
                                flaggedLinks: [], // 不審な寄付（今回は使用しない）
                                projectsMap
                            };
                        }

                        // 位置計算関数
                        function calculatePositions(data) {
                            const { projects, donors, links, flaggedLinks } = data;

                            // 全ノードのリスト
                            const nodes = [
                                ...projects.map(p => ({ id: p.id, type: 'project', name: p.name })),
                                ...donors.map(d => ({ id: d.id, type: 'donor' }))
                            ];

                            // 初期位置を設定
                            const positions = {};

                            // 通常プロジェクトは中央付近に配置
                            projects.forEach(project => {
                                positions[project.id] = {
                                    x: (Math.random() - 0.5) * 50,
                                    y: (Math.random() - 0.5) * 50,
                                    z: (Math.random() - 0.5) * 50
                                };
                            });

                            // ドナーの初期位置
                            donors.forEach(donor => {
                                const donorLinks = links.filter(link => link.source === donor.id);

                                // 寄付しているドナー
                                if (donorLinks.length > 0) {
                                    // 寄付先プロジェクトの平均位置 + ランダム
                                    let sumX = 0, sumY = 0, sumZ = 0;

                                    donorLinks.forEach(link => {
                                        const projectPos = positions[link.target];
                                        if (projectPos) {
                                            sumX += projectPos.x;
                                            sumY += projectPos.y;
                                            sumZ += projectPos.z;
                                        }
                                    });

                                    const avgX = sumX / donorLinks.length || 0;
                                    const avgY = sumY / donorLinks.length || 0;
                                    const avgZ = sumZ / donorLinks.length || 0;

                                    positions[donor.id] = {
                                        x: avgX + (Math.random() - 0.5) * 30,
                                        y: avgY + (Math.random() - 0.5) * 30,
                                        z: avgZ + (Math.random() - 0.5) * 30
                                    };
                                }
                                // 寄付していないドナー
                                else {
                                    positions[donor.id] = {
                                        x: (Math.random() - 0.5) * 100,
                                        y: (Math.random() - 0.5) * 100,
                                        z: (Math.random() - 0.5) * 100
                                    };
                                }
                            });

                            // フォースシミュレーション
                            const iterations = 150;

                            // 力の係数
                            const repulsionForce = 1000;  // 反発力
                            const attractionForce = 0.1;  // 引力

                            for (let iter = 0; iter < iterations; iter++) {
                                // 各ノードに作用する力
                                const forces = {};
                                nodes.forEach(node => {
                                    forces[node.id] = { x: 0, y: 0, z: 0 };
                                });

                                // 反発力（効率化のため近いノードのみ）
                                for (let i = 0; i < nodes.length; i++) {
                                    for (let j = i + 1; j < nodes.length; j++) {
                                        const nodeA = nodes[i];
                                        const nodeB = nodes[j];
                                        const posA = positions[nodeA.id];
                                        const posB = positions[nodeB.id];

                                        if (!posA || !posB) continue;

                                        const dx = posB.x - posA.x;
                                        const dy = posB.y - posA.y;
                                        const dz = posB.z - posA.z;

                                        const distSq = dx*dx + dy*dy + dz*dz;
                                        const dist = Math.sqrt(distSq) || 0.1;

                                        // 一定距離以上離れたノードは無視
                                        if (dist > 150) continue;

                                        // プロジェクト同士は強く反発
                                        let force = repulsionForce / distSq;
                                        if (nodeA.type === 'project' && nodeB.type === 'project') {
                                            force *= 3; // プロジェクト同士の反発を強く
                                        }

                                        // 距離の単位ベクトル
                                        const ux = dx / dist;
                                        const uy = dy / dist;
                                        const uz = dz / dist;

                                        // ノードAへの力（反対方向）
                                        forces[nodeA.id].x -= force * ux;
                                        forces[nodeA.id].y -= force * uy;
                                        forces[nodeA.id].z -= force * uz;

                                        // ノードBへの力（同じ方向）
                                        forces[nodeB.id].x += force * ux;
                                        forces[nodeB.id].y += force * uy;
                                        forces[nodeB.id].z += force * uz;
                                    }
                                }

                                // 引力（リンク）
                                links.forEach(link => {
                                    const sourcePos = positions[link.source];
                                    const targetPos = positions[link.target];

                                    if (!sourcePos || !targetPos) return;

                                    const dx = targetPos.x - sourcePos.x;
                                    const dy = targetPos.y - sourcePos.y;
                                    const dz = targetPos.z - sourcePos.z;

                                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) || 0.1;

                                    // 寄付額に応じた引力
                                    const force = attractionForce * dist * Math.sqrt(link.value / 500);

                                    // 距離の単位ベクトル
                                    const ux = dx / dist;
                                    const uy = dy / dist;
                                    const uz = dz / dist;

                                    // ドナーからプロジェクトへの引力
                                    forces[link.source].x += force * ux;
                                    forces[link.source].y += force * uy;
                                    forces[link.source].z += force * uz;

                                    // プロジェクトへの引力は弱めに
                                    forces[link.target].x -= force * ux * 0.2;
                                    forces[link.target].y -= force * uy * 0.2;
                                    forces[link.target].z -= force * uz * 0.2;
                                });

                                // 位置更新
                                nodes.forEach(node => {
                                    const force = forces[node.id];
                                    const pos = positions[node.id];

                                    if (!force || !pos) return;

                                    // 減衰係数
                                    const damping = 0.95 - (iter / iterations * 0.7);

                                    // 他のノードは力に従って移動
                                    pos.x += force.x * damping;
                                    pos.y += force.y * damping;
                                    pos.z += force.z * damping;
                                });
                            }

                            return positions;
                        }

                        // データを処理
                        const data = processData();

                        // 位置計算
                        const positions = calculatePositions(data);

                        // プロジェクトのサイズを寄付額に応じて計算
                        const getProjectSize = (project) => {
                            // 寄付総額に基づいてサイズを決定（対数スケール）
                            return Math.max(18, Math.min(35, 15 + Math.log(project.donationTotal + 1) * 2));
                        };

                        // プロジェクトトレース
                        const projectsX = [];
                        const projectsY = [];
                        const projectsZ = [];
                        const projectSizes = [];
                        const projectHoverTexts = [];
                        const projectNames = [];

                        // 最大寄付額を計算して、サイズの正規化に使用
                        const maxDonation = Math.max(...data.projects.map(p => p.donationTotal || 1));

                        data.projects.forEach(project => {
                            if (positions[project.id]) {
                                projectsX.push(positions[project.id].x);
                                projectsY.push(positions[project.id].y);
                                projectsZ.push(positions[project.id].z);

                                // 寄付総額に基づいてサイズを計算（より明確な差を表現）
                                const normalizedSize = (project.donationTotal / maxDonation);
                                const size = Math.max(15, Math.min(40, 15 + normalizedSize * 25));
                                projectSizes.push(size);

                                projectNames.push(project.name);

                                // ホバーテキスト
                                projectHoverTexts.push(
                                    `<span style="font-weight: bold; color: #4fc3f7; font-size: 14px;">${project.name}</span><br>` +
                                    `寄付者数: ${project.donorCount}人<br>` +
                                    `寄付総額: ${Math.floor(project.donationTotal).toLocaleString()} JPY<br>` +
                                    `このプロジェクトだけを支援している人の数: ${project.exclusiveDonorCount}人 (${(project.exclusiveDonorRatio * 100).toFixed(1)}%)`
                                );
                            }
                        });

                        const projectTrace = {
                            x: projectsX,
                            y: projectsY,
                            z: projectsZ,
                            mode: "markers+text",
                            type: "scatter3d",
                            marker: {
                                size: projectSizes,
                                color: "#4fc3f7",  // 明るい青色に変更
                                opacity: 0.9,
                                line: {
                                    color: "#29b6f6",
                                    width: 2
                                }
                            },
                            text: projectNames,
                            textposition: "top center",
                            textfont: {
                                color: "#e0e0e0",
                                size: 10
                            },
                            name: "プロジェクト",
                            hoverinfo: "text",
                            hovertext: projectHoverTexts
                        };

                        // ドナートレース
                        const donorIds = data.donors.map(d => d.id);

                        const donorX = donorIds
                            .filter(id => positions[id])
                            .map(id => positions[id].x);

                        const donorY = donorIds
                            .filter(id => positions[id])
                            .map(id => positions[id].y);

                        const donorZ = donorIds
                            .filter(id => positions[id])
                            .map(id => positions[id].z);

                        const donorTrace = {
                            x: donorX,
                            y: donorY,
                            z: donorZ,
                            mode: "markers",
                            type: "scatter3d",
                            marker: {
                                size: 4,
                                color: "#ff5252",  // 明るい赤色に変更
                                opacity: 0.7
                            },
                            name: "寄付者",
                            hoverinfo: "skip"
                        };

                        // 寄付リンク
                        let edgeX = [], edgeY = [], edgeZ = [];

                        // すべての寄付を処理
                        data.links.forEach(link => {
                            const sourcePos = positions[link.source];
                            const targetPos = positions[link.target];

                            if (!sourcePos || !targetPos) return;

                            edgeX.push(sourcePos.x, targetPos.x, null);
                            edgeY.push(sourcePos.y, targetPos.y, null);
                            edgeZ.push(sourcePos.z, targetPos.z, null);
                        });

                        const edgeTrace = {
                            x: edgeX,
                            y: edgeY,
                            z: edgeZ,
                            mode: "lines",
                            type: "scatter3d",
                            line: {
                                color: "#69f0ae",  // 明るい緑色に変更
                                width: 2,
                                opacity: 0.4
                            },
                            name: "寄付",
                            hoverinfo: "skip"
                        };

                        // 全トレースを集める
                        const traces = [edgeTrace, projectTrace, donorTrace];

                        // レイアウト
                        const layout = {
                            title: {
                                text: 'COCM 3D Network Visualization',
                                font: { color: '#f0f0f0' }
                            },
                            height: 600,
                            scene: {
                                aspectmode: "cube",
                                camera: {
                                    eye: { x: 1.8, y: 1.8, z: 1.8 },
                                    up: { x: 0, y: 0, z: 1 }
                                },
                                xaxis: {
                                    showgrid: true,
                                    gridcolor: '#444',
                                    tickfont: { color: '#f0f0f0' },
                                    backgroundcolor: '#121212',
                                    zerolinecolor: '#444'
                                },
                                yaxis: {
                                    showgrid: true,
                                    gridcolor: '#444',
                                    tickfont: { color: '#f0f0f0' },
                                    backgroundcolor: '#121212',
                                    zerolinecolor: '#444'
                                },
                                zaxis: {
                                    showgrid: true,
                                    gridcolor: '#444',
                                    tickfont: { color: '#f0f0f0' },
                                    backgroundcolor: '#121212',
                                    zerolinecolor: '#444'
                                },
                                bgcolor: '#121212'
                            },
                            margin: { l: 0, r: 0, b: 0, t: 50 },
                            showlegend: true,
                            legend: {
                                x: 0,
                                y: 1,
                                font: { color: '#f0f0f0' },
                                bgcolor: '#1e1e1e',
                                bordercolor: '#444'
                            },
                            hoverlabel: {
                                bgcolor: '#1e1e1e',
                                font: { color: '#f0f0f0', size: 12 },
                                bordercolor: '#444'
                            },
                            paper_bgcolor: '#121212',
                            plot_bgcolor: '#121212'
                        };

                        // 描画
                        Plotly.newPlot('network3dDiv', traces, layout, {
                            responsive: true,
                            displayModeBar: true
                        });

                        // 実際に表示されているノード数を出力
                        console.log("実際に表示されているノード数:");
                        console.log(`表示されているプロジェクト数: ${projectsX.length}`);
                        console.log(`表示されている寄付者数: ${donorX.length}`);
                        console.log(`総ノード数: ${projectsX.length + donorX.length}`);

                    } catch (e) {
                        console.error("3Dネットワーク描画中にエラーが発生しました:", e);
                    }
                }, 500); // 500ミリ秒の遅延

                // クリーンアップ関数
                return () => clearTimeout(timer);
            }, [donors, projects, tableData, links, donationMatrix, assignments, rawDonationData]);

            /**
             * 2Dクラスタリング可視化
             *
             * PCAで寄付データを2次元に圧縮し、k-meansクラスタリング結果を可視化します。
             * 類似した寄付パターンを持つ寄付者が同じ色でグループ化されて表示されます。
             * これにより、寄付者の行動パターンの類似性を視覚的に把握できます。
             */
            React.useEffect(() => {
                if (donors.length === 0 || projects.length === 0 || !assignments.length || donationMatrix.length === 0) {
                    return; // データが不足している場合は描画しない
                }

                // 描画処理を少し遅らせる
                const timer = setTimeout(() => {
                    try {
                        // DOM要素が存在するか確認
                        const element = document.getElementById("cluster2dDiv");
                        if (!element) {
                            console.warn("cluster2dDiv要素が見つかりません");
                            return;
                        }

                        const pcaCoords = pcaProjection(donationMatrix, 2);
                        if (!pcaCoords.length) {
                            console.warn("PCA座標が生成できませんでした");
                            return;
                        }

                        // グループごとに色分け（シンプルに3クラスタ）
                        const colors = ["red", "blue", "green"];
                        const clusters = {};
                        assignments.forEach((a, i) => {
                            if (!clusters[a]) clusters[a] = [];
                            clusters[a].push(i);
                        });
                        const traces = [];
                        Object.keys(clusters).forEach(clusterId => {
                            const indices = clusters[clusterId];
                            const jitter = val => val + (Math.random() - 0.5) * 0.2;
                            const xs = indices.map(i => jitter(pcaCoords[i][0]));
                            const ys = indices.map(i => jitter(pcaCoords[i][1]));
                            traces.push({
                                x: xs,
                                y: ys,
                                mode: "markers",
                                type: "scatter",
                                marker: { size: 12, color: colors[clusterId % colors.length] },
                                name: `Cluster ${+clusterId + 1}`
                            });
                        });
                        Plotly.newPlot("cluster2dDiv", traces, {
                            title: "Donor Clustering (PCA + k-means)",
                            height: 600,
                            xaxis: { title: "PC1", color: "#f0f0f0", gridcolor: "#333" },
                            yaxis: { title: "PC2", color: "#f0f0f0", gridcolor: "#333" },
                            paper_bgcolor: "#121212",
                            plot_bgcolor: "#121212",
                            font: { color: "#f0f0f0" }
                        });
                    } catch (e) {
                        console.error("クラスタリング可視化中にエラーが発生しました:", e);
                    }
                }, 500); // 500ミリ秒の遅延

                // クリーンアップ関数
                return () => clearTimeout(timer);
            }, [donationMatrix, assignments, rawDonationData]);

            // QFシミュレーショングラフ（通常のQFとCOCMを左右に並べて表示）
            // バーチャート：プロジェクト別寄付総額とマッチング額
            React.useEffect(() => {
                if (!projectSummaries_normal || !projectSummaries_normal.length ||
                    !projectSummaries_cocm || !projectSummaries_cocm.length) {
                    return; // データが不足している場合は描画しない
                }

                // 描画処理を少し遅らせる
                const timer = setTimeout(() => {
                    try {
                        // DOM要素が存在するか確認
                        const normalElement = document.getElementById("barChartNormalDiv");
                        const cocmElement = document.getElementById("barChartCOCMDiv");
                        if (!normalElement || !cocmElement) {
                            console.warn("barChartNormalDiv または barChartCOCMDiv 要素が見つかりません");
                            return;
                        }

                        // 通常QF
                        const sorted_normal = [...projectSummaries_normal].sort((a, b) => (b.totalDonation + b.finalMatchingFunds) - (a.totalDonation + a.finalMatchingFunds));
                        const projectNames_normal = sorted_normal.map(p => {
                            return window.grantsData && window.grantsData.find(g => g.id === p.project)
                                ? window.grantsData.find(g => g.id === p.project).name
                                : p.project;
                        });
                        const donationTotals_normal = sorted_normal.map(p => p.totalDonation);
                        const matchingFunds_normal = sorted_normal.map(p => p.finalMatchingFunds);
                        const trace1_normal = {
                            x: projectNames_normal,
                            y: donationTotals_normal,
                            type: "bar",
                            name: "支援額",
                            marker: { color: "red" }
                        };
                        const trace2_normal = {
                            x: projectNames_normal,
                            y: matchingFunds_normal,
                            type: "bar",
                            name: "マッチング額",
                            marker: { color: "green" }
                        };
                        Plotly.newPlot("barChartNormalDiv", [trace1_normal, trace2_normal], {
                            title: "【通常QF】プロジェクト別寄付総額とマッチング額",
                            barmode: "stack",
                            yaxis: { title: "金額 (円)", color: "#f0f0f0", gridcolor: "#333" },
                            xaxis: { color: "#f0f0f0", gridcolor: "#333" },
                            paper_bgcolor: "#121212",
                            plot_bgcolor: "#121212",
                            font: { color: "#f0f0f0" }
                        });

                        // COCM
                        const sorted_cocm = [...projectSummaries_cocm].sort((a, b) => (b.totalDonation + b.finalMatchingFunds) - (a.totalDonation + a.finalMatchingFunds));
                        const projectNames_cocm = sorted_cocm.map(p => {
                            return window.grantsData && window.grantsData.find(g => g.id === p.project)
                                ? window.grantsData.find(g => g.id === p.project).name
                                : p.project;
                        });
                        const donationTotals_cocm = sorted_cocm.map(p => p.totalDonation);
                        const matchingFunds_cocm = sorted_cocm.map(p => p.finalMatchingFunds);
                        const trace1_cocm = {
                            x: projectNames_cocm,
                            y: donationTotals_cocm,
                            type: "bar",
                            name: "支援額",
                            marker: { color: "red" }
                        };
                        const trace2_cocm = {
                            x: projectNames_cocm,
                            y: matchingFunds_cocm,
                            type: "bar",
                            name: "マッチング額",
                            marker: { color: "green" }
                        };
                        Plotly.newPlot("barChartCOCMDiv", [trace1_cocm, trace2_cocm], {
                            title: "【COCM QF】プロジェクト別寄付総額とマッチング額",
                            barmode: "stack",
                            yaxis: { title: "金額 (円)", color: "#f0f0f0", gridcolor: "#333" },
                            xaxis: { color: "#f0f0f0", gridcolor: "#333" },
                            paper_bgcolor: "#121212",
                            plot_bgcolor: "#121212",
                            font: { color: "#f0f0f0" }
                        });
                    } catch (e) {
                        console.error("バーチャート描画中にエラーが発生しました:", e);
                    }
                }, 500); // 500ミリ秒の遅延

                // クリーンアップ関数
                return () => clearTimeout(timer);
            }, [projectSummaries_normal, projectSummaries_cocm, matchingPool, rawDonationData]);

            // ライングラフ：順位別割り当て総額の配分
            React.useEffect(() => {
                if (!projectSummaries_normal || !projectSummaries_normal.length ||
                    !projectSummaries_cocm || !projectSummaries_cocm.length) {
                    return; // データが不足している場合は描画しない
                }

                // 描画処理を少し遅らせる
                const timer = setTimeout(() => {
                    try {
                        // DOM要素が存在するか確認
                        const normalElement = document.getElementById("lineChartNormalDiv");
                        const cocmElement = document.getElementById("lineChartCOCMDiv");
                        // 通常QF
                        const sorted_normal = [...projectSummaries_normal].sort((a, b) => (b.totalDonation + b.finalMatchingFunds) - (a.totalDonation + a.finalMatchingFunds));
                        const ranks_normal = sorted_normal.map((_, i) => i + 1);
                        const allocatedAmounts_normal = sorted_normal.map(p => p.totalDonation + p.finalMatchingFunds);
                        const trace_normal = {
                            x: ranks_normal,
                            y: allocatedAmounts_normal,
                            mode: "lines+markers",
                            type: "scatter",
                            name: "割り当て総額"
                        };
                        Plotly.newPlot("lineChartNormalDiv", [trace_normal], {
                            title: "【通常QF】順位別割り当て総額の配分",
                            xaxis: { title: "順位", tickmode: "linear", dtick: 1, color: "#f0f0f0", gridcolor: "#333" },
                            yaxis: { title: "割り当て総額 (円)", color: "#f0f0f0", gridcolor: "#333" },
                            paper_bgcolor: "#121212",
                            plot_bgcolor: "#121212",
                            font: { color: "#f0f0f0" }
                        });

                        // COCM
                        const sorted_cocm = [...projectSummaries_cocm].sort((a, b) => (b.totalDonation + b.finalMatchingFunds) - (a.totalDonation + a.finalMatchingFunds));
                        const ranks_cocm = sorted_cocm.map((_, i) => i + 1);
                        const allocatedAmounts_cocm = sorted_cocm.map(p => p.totalDonation + p.finalMatchingFunds);
                        const trace_cocm = {
                            x: ranks_cocm,
                            y: allocatedAmounts_cocm,
                            mode: "lines+markers",
                            type: "scatter",
                            name: "割り当て総額"
                        };
                        Plotly.newPlot("lineChartCOCMDiv", [trace_cocm], {
                            title: "【COCM QF】順位別割り当て総額の配分",
                            xaxis: { title: "順位", tickmode: "linear", dtick: 1, color: "#f0f0f0", gridcolor: "#333" },
                            yaxis: { title: "割り当て総額 (円)", color: "#f0f0f0", gridcolor: "#333" },
                            paper_bgcolor: "#121212",
                            plot_bgcolor: "#121212",
                            font: { color: "#f0f0f0" }
                        });
                    } catch (e) {
                        console.error("ライングラフ描画中にエラーが発生しました:", e);
                    }
                }, 500); // 500ミリ秒の遅延

                // クリーンアップ関数
                return () => clearTimeout(timer);
            }, [projectSummaries_normal, projectSummaries_cocm, matchingPool, rawDonationData]);

            // 累積資金配分グラフ
            React.useEffect(() => {
                if (!projectSummaries_normal || !projectSummaries_normal.length ||
                    !projectSummaries_cocm || !projectSummaries_cocm.length) {
                    return; // データが不足している場合は描画しない
                }

                // 描画処理を少し遅らせる
                const timer = setTimeout(() => {
                    try {
                        // DOM要素が存在するか確認
                        const normalElement = document.getElementById("cumDistNormalDiv");
                        const cocmElement = document.getElementById("cumDistCOCMDiv");
                        if (!normalElement || !cocmElement) {
                            console.warn("cumDistNormalDiv または cumDistCOCMDiv 要素が見つかりません");
                            return;
                        }

                        // 通常QF
                        const sorted_normal = [...projectSummaries_normal].sort((a, b) => (b.totalDonation + b.finalMatchingFunds) - (a.totalDonation + a.finalMatchingFunds));
                        const totalProjects_normal = sorted_normal.length;
                        const totalTotal_normal = sorted_normal.reduce((sum, p) => sum + (p.totalDonation + p.finalMatchingFunds), 0);
                        let cumTotal_normal = [];
                        sorted_normal.forEach((p, i) => {
                            cumTotal_normal[i] = i === 0 ? p.totalDonation + p.finalMatchingFunds : cumTotal_normal[i - 1] + (p.totalDonation + p.finalMatchingFunds);
                        });
                        const xPercent_normal = sorted_normal.map((_, i) => ((i + 1) / totalProjects_normal) * 100);
                        const yTotal_normal = cumTotal_normal.map(val => (val / totalTotal_normal) * 100);
                        const traceTotal_normal = {
                            x: xPercent_normal,
                            y: yTotal_normal,
                            mode: "lines+markers",
                            type: "scatter",
                            name: "累積総額",
                            line: { color: "#64b5f6" }  // 黒から明るい青色に変更
                        };
                        Plotly.newPlot("cumDistNormalDiv", [traceTotal_normal], {
                            title: "【通常QF】累積資金配分グラフ",
                            xaxis: { title: "プロジェクトランクのパーセンテージ (%)", color: "#f0f0f0", gridcolor: "#333" },
                            yaxis: { title: "累積割合 (%)", color: "#f0f0f0", gridcolor: "#333" },
                            paper_bgcolor: "#121212",
                            plot_bgcolor: "#121212",
                            font: { color: "#f0f0f0" }
                        });

                        // COCM
                        const sorted_cocm = [...projectSummaries_cocm].sort((a, b) => (b.totalDonation + b.finalMatchingFunds) - (a.totalDonation + a.finalMatchingFunds));
                        const totalProjects_cocm = sorted_cocm.length;
                        const totalTotal_cocm = sorted_cocm.reduce((sum, p) => sum + (p.totalDonation + p.finalMatchingFunds), 0);
                        let cumTotal_cocm = [];
                        sorted_cocm.forEach((p, i) => {
                            cumTotal_cocm[i] = i === 0 ? p.totalDonation + p.finalMatchingFunds : cumTotal_cocm[i - 1] + (p.totalDonation + p.finalMatchingFunds);
                        });
                        const xPercent_cocm = sorted_cocm.map((_, i) => ((i + 1) / totalProjects_cocm) * 100);
                        const yTotal_cocm = cumTotal_cocm.map(val => (val / totalTotal_cocm) * 100);
                        const traceTotal_cocm = {
                            x: xPercent_cocm,
                            y: yTotal_cocm,
                            mode: "lines+markers",
                            type: "scatter",
                            name: "累積総額",
                            line: { color: "#64b5f6" }  // 黒から明るい青色に変更
                        };
                        Plotly.newPlot("cumDistCOCMDiv", [traceTotal_cocm], {
                            title: "【COCM QF】累積資金配分グラフ",
                            xaxis: { title: "プロジェクトランクのパーセンテージ (%)", color: "#f0f0f0", gridcolor: "#333" },
                            yaxis: { title: "累積割合 (%)", color: "#f0f0f0", gridcolor: "#333" },
                            paper_bgcolor: "#121212",
                            plot_bgcolor: "#121212",
                            font: { color: "#f0f0f0" }
                        });
                    } catch (e) {
                        console.error("累積資金配分グラフ描画中にエラーが発生しました:", e);
                    }
                }, 500); // 500ミリ秒の遅延

                // クリーンアップ関数
                return () => clearTimeout(timer);
            }, [projectSummaries_normal, projectSummaries_cocm, matchingPool, rawDonationData]);

            // ----------------- JSXレンダリング -----------------
            return (
                <div className="p-6">
                    <h1 className="text-3xl font-bold mb-4">
                        DigDAO QF Simulation Comparison
                    </h1>

                    <div className="info-box">
                        <h2 className="text-xl font-bold mb-2">このシミュレーションについて</h2>
                        <p>このページでは、<span className="highlight">DigDAO</span>の寄付データを使用して、<span className="highlight">通常のQF（Quadratic Funding）</span>と<span className="highlight">COCM QF（Connection-Oriented Cluster Matching QF）</span>の比較シミュレーションを行っています。このシミュレーションを通じて、コミュニティの多様性を重視するCOCM QFがどのように資金配分を改善するかを視覚的に理解できます。</p>

                        <h3 className="text-xl font-bold mt-4 mb-2">Quadratic Funding（QF）とは？</h3>
                        <p>QFは公共財の資金調達メカニズムで、少額の寄付者からの支援を重視し、多くの人から支持されるプロジェクトに対してマッチングファンドを多く配分します。計算式は「寄付額の平方根の合計を二乗」することで、多くの小口寄付が大口寄付よりも効果的になります。これにより、コミュニティの「声の大きさ」ではなく「声の数」が重視されます。</p>

                        <p>QFは元々Vitalik Buterin, Zoe Hitzig, E. Glen Weylらによって「A Flexible Design for Funding Public Goods」という論文で提案されたメカニズムで、Quadratic Votingという仕組みを公共財への資金分配に応用したものです。</p>

                        <h3 className="text-xl font-bold mt-4 mb-2">QFの社会実装例</h3>
                        <p>QFは理論だけでなく、すでに様々な場所で実装されています：</p>
                        <ul style={{ marginLeft: "20px", listStyleType: "disc" }}>
                            <li><span className="highlight">Gitcoin</span>：Ethereumエコシステムで2019年から20回以上のラウンドを実施し、90億円以上の資金をオープンソースプロジェクトに分配</li>
                            <li><span className="highlight">コロラド州</span>：「Downtown Stimulus」プロジェクトでCOVID-19の被害を受けた飲食店支援に活用</li>
                            <li><span className="highlight">UNICEF</span>：Gitcoinとパートナーシップを結び、NGOへの資金分配に活用</li>
                            <li><span className="highlight">台湾デジタル庁</span>：クラウドファンディング事業者と連携し、法定通貨を使ったQF実験を実施</li>
                            <li><span className="highlight">DigDAO</span>：日本で「マッチングドネーション」プロジェクトを実施し、179,962円の寄付と111,651円のマッチングプールで18件のプロジェクトを支援</li>
                        </ul>

                        <h3 className="text-xl font-bold mt-4 mb-2">COCM QF（Connection-Oriented Cluster Matching）とは？</h3>
                        <p>COCMは通常のQFを拡張したもので、<span className="highlight">寄付者の多様性</span>を重視します。従来のQFでは、組織的な寄付行動（Sybil攻撃）や同質的なコミュニティによる集中的な支援が課題でした。COCMでは寄付パターンに基づいて寄付者をクラスタリングし、<span className="highlight">多様なクラスター（異なるコミュニティ）</span>から支持を集めるプロジェクトに追加のボーナスを与えます。</p>

                        <p>COCMの主な特徴：</p>
                        <ul style={{ marginLeft: "20px", listStyleType: "disc" }}>
                            <li><span className="highlight">クラスタリング</span>：寄付パターンの類似性に基づいて寄付者をグループ化</li>
                            <li><span className="highlight">多様性ボーナス</span>：異なるクラスターからの支持を集めるプロジェクトを優遇</li>
                            <li><span className="highlight">コミュニティ間の架け橋</span>：異なるコミュニティをつなぐプロジェクトを促進</li>
                            <li><span className="highlight">Sybil耐性の向上</span>：同質的なグループからの集中的な寄付の影響を軽減</li>
                        </ul>

                        <h3 className="text-xl font-bold mt-4 mb-2">COCMの計算方法</h3>
                        <p>COCMでは、通常のQF計算に<span className="highlight">多様性係数</span>を組み込みます：</p>
                        <ol style={{ marginLeft: "20px", listStyleType: "decimal" }}>
                            <li>寄付者をクラスタリングしてグループ化（このシミュレーションでは3クラスタ）</li>
                            <li>各プロジェクトが支援を受けた<span className="highlight">クラスターの数</span>をカウント</li>
                            <li>クラスター数を総クラスター数で割って<span className="highlight">多様性係数</span>を計算</li>
                            <li>通常のQFスコアに多様性係数を掛け、さらにボーナス（+0.5）を加えて最終スコアを算出</li>
                            <li>マッチングプールを各プロジェクトの最終スコアに比例して配分</li>
                        </ol>

                        <h3 className="text-xl font-bold mt-4 mb-2">DigDAOマッチングドネーションの結果</h3>
                        <p>2024年7月に実施されたDigDAOマッチングドネーション実験では、以下の結果が得られました：</p>
                        <ul style={{ marginLeft: "20px", listStyleType: "disc" }}>
                            <li>110人の寄付者が18件のプロジェクトに179,962円を寄付</li>
                            <li>111,651円のマッチングプールをQFメカニズムで分配</li>
                            <li>「第3の家族」（46人の支持者）や「支援みつもりヤドカリくん」（27人の支持者）など、当事者の課題意識から作られたプロジェクトが上位にランクイン</li>
                            <li>資金配分はべき乗分布に近いが、ロングテールにもプロジェクトを支援できる結果に</li>
                            <li>上位22.2%のプロジェクトが総資金の約50%を獲得する比較的おだやかな分配曲線</li>
                        </ul>

                        <h3 className="text-xl font-bold mt-4 mb-2">このシミュレーションの見方</h3>
                        <p>左側のパネルは<span className="highlight">通常のQF</span>、右側のパネルは<span className="highlight">COCM QF</span>の結果を表示しています。グラフや表を比較することで、多様性を重視するCOCM QFがどのようにプロジェクトへの資金配分を変化させるかを確認できます。特に注目すべき点は、多様なコミュニティから支持を集めるプロジェクトがCOCMでより多くのマッチングファンドを受け取る傾向があることです。</p>

                        <p className="mt-4">詳細な可視化：</p>
                        <ul style={{ marginLeft: "20px", listStyleType: "disc" }}>
                            <li><span className="highlight">Sankey Diagram</span>：寄付者からプロジェクトへの資金フローを表示</li>
                            <li><span className="highlight">3D Network</span>：寄付者とプロジェクトの関係を3D空間で可視化。クラスター間の関係性が見えます</li>
                            <li><span className="highlight">Donor Clustering</span>：寄付パターンに基づく寄付者のグループ化。同じ色の点は類似した寄付行動を示します</li>
                            <li><span className="highlight">QF比較表</span>：各プロジェクトの寄付者数、多様性係数、寄付総額、マッチング額を比較</li>
                        </ul>

                        <p className="mt-4">COCMについての詳細は<a href="https://www.gitcoin.co/blog/wtf-is-cluster-matching-qf" target="_blank">Gitcoinのブログ記事</a>や<a href="https://wtfiscocm.streamlit.app/COCM_Sandbox" target="_blank">COCMサンドボックス</a>をご覧ください。</p>

                        <p className="mt-4">DigDAOマッチングドネーションの詳細な結果は<a href="https://note.com/tkgshn/n/nfa5142139665" target="_blank">こちらの記事</a>をご覧ください。</p>
                    </div>

                    {isLoading ? (
                        <div>データを読み込み中です...</div>
                    ) : error ? (
                        <div style={{ color: 'red' }}>{error}</div>
                    ) : rawDonationData.length === 0 ? (
                        <div>データが見つかりませんでした。</div>
                    ) : (
                        <React.Fragment>
                            <div className="mb-4">
                                <label>
                                    Matching Fund プール (円):
                                    <input
                                        type="number"
                                        value={matchingPool}
                                        onChange={(e) => setMatchingPool(Number(e.target.value))}
                                        style={{ width: "120px" }}
                                    />
                                </label>
                                <button onClick={() => setRefresh(r => r + 1)} style={{ marginLeft: "20px" }}>
                                    Refresh Data
                                </button>
                            </div>
                            {/* Sankey Diagram */}
                            <div id="sankeyDiv"></div>
                            {/* 3D Network & 2D Clustering */}
                            <div className="flex">
                                <div className="half">
                                    <div id="network3dDiv" style={{ height: "600px" }}></div>
                                </div>
                                <div className="half">
                                    <div id="cluster2dDiv" style={{ height: "600px" }}></div>
                                </div>
                            </div>
                            {/* QF Simulation Comparison */}
                            <h2 className="text-3xl font-bold mt-6">QF Simulation Comparison</h2>
                            <div className="flex">
                                {/* 左側：通常QF */}
                                <div className="half">
                                    <h3 className="text-xl font-bold">通常 QF</h3>
                                    <table>
                                        <colgroup>
                                            <col style={{ width: "30%" }} />
                                            <col style={{ width: "15%" }} />
                                            <col style={{ width: "20%" }} />
                                            <col style={{ width: "17.5%" }} />
                                            <col style={{ width: "17.5%" }} />
                                        </colgroup>
                                        <thead>
                                            <tr>
                                                <th>Project</th>
                                                <th>寄付者数</th>
                                                <th>多様性係数</th>
                                                <th>寄付総額</th>
                                                <th>Matching Fund上乗せ額</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {projectSummaries_normal && projectSummaries_normal.map((p, idx) => (
                                                <tr key={idx}>
                                                    <td>{window.grantsData && window.grantsData.find(g => g.id === p.project) ? window.grantsData.find(g => g.id === p.project).name : p.project}</td>
                                                    <td>{p.donorCount}</td>
                                                    <td>{p.diversityFactor.toFixed(2)}</td>
                                                    <td>¥{Math.floor(p.totalDonation).toLocaleString()}</td>
                                                    <td>¥{Math.round(p.finalMatchingFunds).toLocaleString()}</td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                    <div id="barChartNormalDiv" style={{ height: "400px", marginTop: "20px" }}></div>
                                    <div id="lineChartNormalDiv" style={{ height: "400px", marginTop: "20px" }}></div>
                                    <div id="cumDistNormalDiv" style={{ height: "400px", marginTop: "20px" }}></div>
                                </div>
                                {/* 右側：COCM QF */}
                                <div className="half">
                                    <h3 className="text-xl font-bold">COCM QF</h3>
                                    <table>
                                        <colgroup>
                                            <col style={{ width: "30%" }} />
                                            <col style={{ width: "15%" }} />
                                            <col style={{ width: "20%" }} />
                                            <col style={{ width: "17.5%" }} />
                                            <col style={{ width: "17.5%" }} />
                                        </colgroup>
                                        <thead>
                                            <tr>
                                                <th>Project</th>
                                                <th>寄付者数</th>
                                                <th>多様性係数</th>
                                                <th>寄付総額</th>
                                                <th>Matching Fund上乗せ額</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {projectSummaries_cocm && projectSummaries_cocm.map((p, idx) => (
                                                <tr key={idx}>
                                                    <td>{window.grantsData && window.grantsData.find(g => g.id === p.project) ? window.grantsData.find(g => g.id === p.project).name : p.project}</td>
                                                    <td>{p.donorCount}</td>
                                                    <td>{p.diversityFactor.toFixed(2)}</td>
                                                    <td>¥{Math.floor(p.totalDonation).toLocaleString()}</td>
                                                    <td>¥{Math.round(p.finalMatchingFunds).toLocaleString()}</td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                    <div id="barChartCOCMDiv" style={{ height: "400px", marginTop: "20px" }}></div>
                                    <div id="lineChartCOCMDiv" style={{ height: "400px", marginTop: "20px" }}></div>
                                    <div id="cumDistCOCMDiv" style={{ height: "400px", marginTop: "20px" }}></div>
                                </div>
                            </div>
                        </React.Fragment>
                    )}
                </div>
            );
        }

        ReactDOM.render(<DonationSimulator />, document.getElementById("root"));
    </script>
</body>
